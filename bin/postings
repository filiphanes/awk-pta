#!/usr/bin/env gawk -f
# Preprocessor for:
# - dates are recognized in ISO format YYYY-MM-DD or YYYY-MM
# - if posting date is missing, last date is used or 0000-01-01
# - if amount is not at $1 or $2 after date, then date, account,
#   tags are set for following postings in transaction
# - if first field is matches account regex it is used in following postings in transaction
# - empty line clears shared variables
# - other lines are ignored

# Outputs simple greppable, sortable, normalized postings lines,
# without comments and unrecognized lines
# With following fixed fields order:
# date amount currency account other tags

BEGIN {
    ACCOUNT_REGEX = ENVIRON["PTA_ACCOUNT_REGEX"]
    if (!ACCOUNT_REGEX) ACCOUNT_REGEX = "^([A-Z]+:)?(expenses|assets|liabilities|income|equity)(:[^ ])?"
    AMOUNT_REGEX = "^[-+]?[0-9]+(\\.[0-9]+)?$"
    dates[1] = "0000-01-01"
    aliases[""] = ""
}

# amount is first
/^[[:space:]]*[-+]?[0-9]+(\.[0-9]+)?([[:space:]]|$)/ {
    # last date is always set to postings without it
    if ($2 ~ ACCOUNT_REGEX) $2 = $2 tags
    else if ($2 in aliases) $2 = aliases[$2] tags
    else if (account)       $1 = $1 " " account tags
    else                    $1 = $1 tags
    for (i in dates) print dates[i], $0
    next
}

# date is first
/^[0-9]{4}-[0-9]{2}(-[0-9]{2})?[[:space:]]/ {
    dates[1] = $1
    if ($2 ~ AMOUNT_REGEX) {
        # print posting only when numeric value is at second field
        if ($3 ~ ACCOUNT_REGEX) $3 = $3 tags
        else if ($3 in aliases) $3 = aliases[$3] tags
        else if (account)       $2 = $2 " " account tags
        else                    $2 = $2 tags
        print
    } else {
        # rest is [account] tags
        if ($2 in aliases) $2 = aliases[$2]
        $1 = ""
        tags = $0
        gsub(/[[:space:]]*$/, "", tags)  # remove all traling spaces
    }
    next
}

# Empty line resets shared tags, date is kept
/^[[:space:]]*$/ {
    account = ""
    tags = ""
    split(dates[1], dates)  # keep only first date
    next
}

# When account is at 1st field it is default for following postings without account
$1 ~ ACCOUNT_REGEX {
    print "account", $1
    account = $1
    if (account in aliases) account = aliases[account]
    $1 = ""
    tags = $0
    gsub(/[[:space:]]*$/, "", tags)  # remove all traling spaces
    next
}

/^alias[[:space:]]/ {
    aliases[$2] = $3
    next
}

# Periodic transaction
/^~[[:space:]]/ {
    since = dates[1]
    for (i=2; i <= NF; i++) {
        if ($i == "every") {
            i++
            if ($1 ~ /^[0-9]+$/) {
                interval = $i
                i++
            } else interval = 1
                 if ($i ~ /^days?/)     interval += "d"
            else if ($i ~ /^weeks?/)    interval += "w"
            else if ($i ~ /^months?/)   interval += "m"
            else if ($i ~ /^quarters?/) interval = (interval*3) "m"
            else if ($i ~ /^years?/)    interval += "y"
        }
        else if ($i == "daily")     interval = "1d"
        else if ($i == "weekly")    interval = "1w"
        else if ($i == "monthly")   interval = "1m"
        else if ($i == "biweekly")  interval = "2w"
        else if ($i == "bimonthly") interval = "2m"
        else if ($i == "quarterly") interval = "3m"
        else if ($i == "yearly")    interval = "1y"
        else if ($i == "since" || $i == "from") since = $(++i)
        else if ($i == "until" || $i == "to")   until = $(++i)
        else if ($i == "in") {
            i++
            #TODO
        }
    }
    # until defaults to 1 year after since
    if (!until) {
        split(since, a, "-")
        a[1]++
        until = sprintf("%04d-%02d-%02d", a[1], a[2], a[3])
    }
    cmd = "bin/gendates " since " " until " " interval
    for (j=1; (cmd | getline d) > 0; j++)
        dates[j] = d
    close(cmd)
}

# Timelog
$1 == "i" {
    datetime = $2 " " $3
    gsub(/[-:]/, " ", datetime)
    time_in = mktime(datetime)
    if (time_in < 0) print "invalid datetime", $2, $3 > /dev/stderr
    time_account = $4
    $1=$2=$3=$4=""
    time_tags = $0
    sub(/^[[:space:]]+/, "", time_tags)
}
$1 == "o" {
    datetime = $2 " " $3
    gsub(/[-:]/, " ", datetime)
    time_out = mktime(datetime)
    if (time_out < 0) print "invalid datetime", $2, $3 > /dev/stderr
    print $2, (time_out-time_in)/3600, "H:" time_account, time_tags
}
